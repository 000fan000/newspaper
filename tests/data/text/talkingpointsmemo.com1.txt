OpenURI::HTTPError at /slideshow/astronomy-photographer-competition-2013 404 Not Found file: open-uri.rb location: open_http line: 277

BACKTRACE (expand) JUMP TO: GET POST COOKIES ENV /usr/lib/ruby/1.8/open-uri.rb in open_http when Net::HTTPSuccess when Net::HTTPMovedPermanently, # 301 Net::HTTPFound, # 302 Net::HTTPSeeOther, # 303 Net::HTTPTemporaryRedirect # 307 throw :open_uri_redirect, URI.parse(resp['location']) else raise OpenURI::HTTPError.new(io.status.join(' '), io) end end class HTTPError < StandardError def initialize(message, io) super(message) @io = io /usr/lib/ruby/1.8/open-uri.rb in buffer_open nil end end end class HTTP def buffer_open(buf, proxy, options) # :nodoc: OpenURI.open_http(buf, self, proxy, options) end include OpenURI::OpenRead end class FTP def buffer_open(buf, proxy, options) # :nodoc: /usr/lib/ruby/1.8/open-uri.rb in open_loop end uri_set = {} buf = nil while true redirect = catch(:open_uri_redirect) { buf = Buffer.new uri.buffer_open(buf, find_proxy.call(uri), options) nil } if redirect if redirect.relative? # Although it violates RFC2616, Location: field may have relative # URI. It is converted to absolute URI using uri as a base URI. redirect = uri + redirect /usr/lib/ruby/1.8/open-uri.rb in catch else raise ArgumentError.new("Invalid proxy option: #{opt_proxy}") end uri_set = {} buf = nil while true redirect = catch(:open_uri_redirect) { buf = Buffer.new uri.buffer_open(buf, find_proxy.call(uri), options) nil } if redirect if redirect.relative? # Although it violates RFC2616, Location: field may have relative /usr/lib/ruby/1.8/open-uri.rb in open_loop else raise ArgumentError.new("Invalid proxy option: #{opt_proxy}") end uri_set = {} buf = nil while true redirect = catch(:open_uri_redirect) { buf = Buffer.new uri.buffer_open(buf, find_proxy.call(uri), options) nil } if redirect if redirect.relative? # Although it violates RFC2616, Location: field may have relative /usr/lib/ruby/1.8/open-uri.rb in open_uri unless mode == nil || mode == 'r' || mode == 'rb' || mode == File::RDONLY raise ArgumentError.new("invalid access mode #{mode} (#{uri.class} resource is read only.)") end io = open_loop(uri, options) if block_given? begin yield io ensure io.close end else /usr/lib/ruby/1.8/open-uri.rb in open # pbar.set s if pbar # }) {|f| ... } # # OpenURI::OpenRead#open returns an IO like object if block is not given. # Otherwise it yields the IO object and return the value of the block. # The IO object is extended with OpenURI::Meta. def open(*rest, &block) OpenURI.open_uri(self, *rest, &block) end # OpenURI::OpenRead#read([options]) reads a content referenced by self and # returns the content as string. # The string is extended with OpenURI::Meta. # The argument `options' is same as OpenURI::OpenRead#open. def read(options={}) /usr/lib/ruby/1.8/open-uri.rb in open # In these case, the opened file object is extended by OpenURI::Meta. def open(name, *rest, &block) # :doc: if name.respond_to?(:open) name.open(*rest, &block) elsif name.respond_to?(:to_str) && %r{\A[A-Za-z][A-Za-z0-9+\-\.]*://} =~ name && (uri = URI.parse(name)).respond_to?(:open) uri.open(*rest, &block) else open_uri_original_open(name, *rest, &block) end end module_function :open end ./attr-app.rb in header key = "headers/#{title.nil? ? '' : title.gsub(/[^a-z0-9]/i, '')}" # outpus output = cache_get key # check the cache for this page if output.nil? output = open("http://talkingpointsmemo.com/includes/header.php?site=TPM%20Media&author=#{CGI::escape(author)}&url=#{CGI::escape(url)}&og-image=#{CGI::escape(image)}&og-url=#{CGI::escape(url)}&title=#{CGI::escape(title)}&og-title=#{CGI::escape(title + ': ' + description)}&description=#{CGI::escape(description)}&ad-leader=TPM_728x90_Slideshow_Leaderboard_ATF&site=TPM%20Media").read cache_set key, output, 3600 end # return the header output end /var/cap/attr/releases/20130708203648/views/gallery.erb in evaluate_source <%= header @slideshow.attributes['author'].first, @slideshow.attributes['title'].first, "http://media.talkingpointsmemo.com#{ @path.chop }", @slideshow.attributes['description'].first, @current.attributes['url'].first %> <style> section#page{min-height:1014px;} #image{box-shadow:0 2px 7px #bbb;} .prev,.next,.prev_off,.next_off{display:inline-block;border:1px solid #ddd;background:#f5f5f5;width:60px;float:left;height:<%= (830 / @current.attributes['width'].first.to_f * @current.attributes['height'].first.to_f).round - 2 %>px;color:#ddd;font-family:helvetica;line-height:<%= (830 / @current.attributes['width'].first.to_f * @current.attributes['height'].first.to_f).round - 2 %>px;text-align:center;font-size:40px;text-shadow:0px 1px 0px #fff;} .prev:hover,.next:hover{text-decoration:none;border:1px solid #ccc;background:#eee;color:#bbb;} .prev,.prev_off{margin-right:10px;border-top-left-radius:5px;border-bottom-left-radius:5px;} .next,.next_off{margin-left:10px;border-top-right-radius:5px;border-bottom-right-radius:5px;} /usr/lib/ruby/gems/1.8/gems/tilt-1.3.1/lib/tilt/template.rb in cached_evaluate # Redefine itself to use method compilation the next time: def self.cached_evaluate(scope, locals, &block) method = compiled_method(locals.keys) method.bind(scope).call(locals, &block) end # Use instance_eval the first time: evaluate_source(scope, locals, &block) end # Generates all template source by combining the preamble, template, and # postamble and returns a two-tuple of the form: [source, offset], where # source is the string containing (Ruby) source code for the template and # offset is the integer line offset where line reporting should begin. # /usr/lib/ruby/gems/1.8/gems/tilt-1.3.1/lib/tilt/template.rb in evaluate compile! else raise NotImplementedError end end def evaluate(scope, locals, &block) cached_evaluate(scope, locals, &block) end # Process the template and return the result. The first time this # method is called, the template source is evaluated with instance_eval. # On the sequential method calls it will compile the template to an # unbound method which will lead to better performance. In any case, # template executation is guaranteed to be performed in the scope object /usr/lib/ruby/gems/1.8/gems/tilt-1.3.1/lib/tilt/template.rb in render prepare end # Render the template in the given scope with the locals specified. If a # block is given, it is typically available within the template via # +yield+. def render(scope=Object.new, locals={}, &block) evaluate scope, locals || {}, &block end # The basename of the template file. def basename(suffix='') File.basename(file, suffix) if file end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in render layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # compile and render template layout_was = @default_layout @default_layout = false template = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) @default_layout = layout_was # render layout if layout options = options.merge(:views => views, :layout => false, :eat_errors => eat_errors, :scope => scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in erb # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def erb(template, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) render :erubis, template, options, locals end def haml(template, options={}, locals={}) ./attr-app.rb in GET (?-mix:^\/slideshow\/([\w-]+)(\/([A-Za-z0-9-]+))?$) related_slideshow.attributes['url'] = slides[0].attributes['url'] related_slideshow.attributes['width'] = slides[0].attributes['width'] related_slideshow.attributes['height'] = slides[0].attributes['height'] end } # render the template output = erb :gallery # store the output cache_set key, output, 86400 end # return the output output /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call define_method(method_name, &block) unbound_method = instance_method method_name pattern, keys = compile(path) conditions, @conditions = @conditions, [] remove_method method_name [ block.arity != 0 ? proc { unbound_method.bind(self).call(*@block_params) } : proc { unbound_method.bind(self).call }, pattern, keys, conditions ] end def compile(path) keys = [] if path.respond_to? :to_str /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in compile! define_method(method_name, &block) unbound_method = instance_method method_name pattern, keys = compile(path) conditions, @conditions = @conditions, [] remove_method method_name [ block.arity != 0 ? proc { unbound_method.bind(self).call(*@block_params) } : proc { unbound_method.bind(self).call }, pattern, keys, conditions ] end def compile(path) keys = [] if path.respond_to? :to_str /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in instance_eval route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def route_eval(&block) throw :halt, instance_eval(&block) end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in route_eval route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def route_eval(&block) throw :halt, instance_eval(&block) end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in route! end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do route_eval(&block) end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in process_route {} end @params = @original_params.merge(params) @block_params = values catch(:pass) do conditions.each { |cond| throw :pass if instance_eval(&cond) == false } yield end end ensure @params = @original_params end # No matching route was found or all routes passed. The default /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in catch elsif values.any? {'captures' => values} else {} end @params = @original_params.merge(params) @block_params = values catch(:pass) do conditions.each { |cond| throw :pass if instance_eval(&cond) == false } yield end end ensure @params = @original_params /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in process_route elsif values.any? {'captures' => values} else {} end @params = @original_params.merge(params) @block_params = values catch(:pass) do conditions.each { |cond| throw :pass if instance_eval(&cond) == false } yield end end ensure @params = @original_params /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in route! base.filters[type].each { |block| instance_eval(&block) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do route_eval(&block) end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in each filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |block| instance_eval(&block) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do route_eval(&block) end end end # Run routes defined in superclass. /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in route! filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |block| instance_eval(&block) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do route_eval(&block) end end end # Run routes defined in superclass. /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in dispatch! res end # Dispatch a request with error handling. def dispatch! static! if settings.static? && (request.get? || request.head?) filter! :before route! rescue NotFound => boom handle_not_found!(boom) rescue ::Exception => boom handle_exception!(boom) ensure filter! :after unless env['sinatra.static_file'] end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call! @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@request.route) force_encoding(@params) @response['Content-Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content-Type'] if body.respond_to?(:to_ary) and body.first.respond_to? :content_type content_type body.first.content_type else content_type :html end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in instance_eval # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def invoke(&block) res = catch(:halt) { instance_eval(&block) } return if res.nil? case when res.respond_to?(:to_str) @response.body = [res] when res.respond_to?(:to_ary) res = res.to_ary /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in invoke # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def invoke(&block) res = catch(:halt) { instance_eval(&block) } return if res.nil? case when res.respond_to?(:to_str) @response.body = [res] when res.respond_to?(:to_ary) res = res.to_ary /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in catch # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def invoke(&block) res = catch(:halt) { instance_eval(&block) } return if res.nil? case when res.respond_to?(:to_str) @response.body = [res] when res.respond_to?(:to_ary) res = res.to_ary /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in invoke # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def invoke(&block) res = catch(:halt) { instance_eval(&block) } return if res.nil? case when res.respond_to?(:to_str) @response.body = [res] when res.respond_to?(:to_ary) res = res.to_ary /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call! @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@request.route) force_encoding(@params) @response['Content-Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content-Type'] if body.respond_to?(:to_ary) and body.first.respond_to? :content_type content_type body.first.content_type else content_type :html end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) /usr/lib/ruby/gems/1.8/gems/rack-1.2.3/lib/rack/head.rb in call class Head def initialize(app) @app = app end def call(env) status, headers, body = @app.call(env) if env["REQUEST_METHOD"] == "HEAD" [status, headers, []] else [status, headers, body] end end /usr/lib/ruby/gems/1.8/gems/rack-1.2.3/lib/rack/commonlogger.rb in call def initialize(app, logger=nil) @app = app @logger = logger end def call(env) began_at = Time.now status, header, body = @app.call(env) header = Utils::HeaderHash.new(header) log(env, status, header, began_at) [status, header, body] end private /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/showexceptions.rb in call def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception => e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if respond_to?(:prefers_plain_text?) and prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else /usr/lib/ruby/gems/1.8/gems/rack-1.2.3/lib/rack/methodoverride.rb in call method = method.to_s.upcase if HTTP_METHODS.include?(method) env["rack.methodoverride.original_method"] = env["REQUEST_METHOD"] env["REQUEST_METHOD"] = method end end @app.call(env) end end end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call setup_sessions builder middleware.each { |c,a,b| builder.use(c, *a, &b) } builder.run new!(*args, &bk) builder end def call(env) synchronize { prototype.call(env) } end private def setup_sessions(builder) return unless sessions? builder.use Rack::Session::Cookie, :secret => session_secret end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in synchronize end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end def metadef(message, &block) (class << self; self; end). send :define_method, message, &block end /usr/lib/ruby/gems/1.8/gems/sinatra-1.2.6/lib/sinatra/base.rb in call setup_sessions builder middleware.each { |c,a,b| builder.use(c, *a, &b) } builder.run new!(*args, &bk) builder end def call(env) synchronize { prototype.call(env) } end private def setup_sessions(builder) return unless sessions? builder.use Rack::Session::Cookie, :secret => session_secret end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/request_handler.rb in process_request if env[HTTPS] == YES || env[HTTPS] == ON || env[HTTPS] == ONE env[RACK_URL_SCHEME] = HTTPS_DOWNCASE else env[RACK_URL_SCHEME] = HTTP end status, headers, body = @app.call(env) begin if full_http_response output.write("HTTP/1.1 #{status.to_i.to_s} Whatever#{CRLF}") output.write("Connection: close#{CRLF}") end headers_output = [ STATUS, status.to_i.to_s, CRLF, /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_request_handler.rb in accept_and_process_next_request if headers prepare_request(headers) begin if headers[REQUEST_METHOD] == PING process_ping(headers, input_stream, connection) else process_request(headers, input_stream, connection, full_http_response) end rescue Exception has_error = true raise ensure finalize_request(headers, has_error) end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_request_handler.rb in main_loop install_useful_signal_handlers socket_wrapper = Utils::UnseekableSocket.new channel = MessageChannel.new buffer = '' while true @iterations += 1 if !accept_and_process_next_request(socket_wrapper, channel, buffer) trace(2, "Request handler main loop exited normally") break end @processed_requests += 1 end rescue EOFError # Exit main loop. /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/application_spawner.rb in start_request_handler app_process = AppProcess.new(app_root, Process.pid, writer, handler.server_sockets) app_process.write_to_channel(channel) writer.close channel.close before_handling_requests(forked, options) handler.main_loop ensure channel.close rescue nil writer.close rescue nil handler.cleanup rescue nil after_handling_requests end end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/application_spawner.rb in send options = sanitize_spawn_options(Hash[*options]) a, b = UNIXSocket.pair safe_fork('application', true) do begin a.close client.close options = @options.merge(options) self.class.send(:start_request_handler, MessageChannel.new(b), @app, true, options) rescue SignalException => e if e.message != AbstractRequestHandler::HARD_TERMINATION_SIGNAL && e.message != AbstractRequestHandler::SOFT_TERMINATION_SIGNAL raise end end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/application_spawner.rb in handle_spawn_application options = sanitize_spawn_options(Hash[*options]) a, b = UNIXSocket.pair safe_fork('application', true) do begin a.close client.close options = @options.merge(options) self.class.send(:start_request_handler, MessageChannel.new(b), @app, true, options) rescue SignalException => e if e.message != AbstractRequestHandler::HARD_TERMINATION_SIGNAL && e.message != AbstractRequestHandler::SOFT_TERMINATION_SIGNAL raise end end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/utils.rb in safe_fork if pid.nil? has_exception = false begin if double_fork pid2 = fork if pid2.nil? srand yield end else srand yield end rescue Exception => e has_exception = true /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/application_spawner.rb in handle_spawn_application end end private def handle_spawn_application(client, *options) options = sanitize_spawn_options(Hash[*options]) a, b = UNIXSocket.pair safe_fork('application', true) do begin a.close client.close options = @options.merge(options) self.class.send(:start_request_handler, MessageChannel.new(b), @app, true, options) rescue SignalException => e /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in __send__ if client_password != password next end name, *args = client.read if name if @message_handlers.has_key?(name) __send__(@message_handlers[name], client, *args) else raise UnknownMessage, "Unknown message '#{name}' received." end end ensure client_socket.close end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in server_main_loop if client_password != password next end name, *args = client.read if name if @message_handlers.has_key?(name) __send__(@message_handlers[name], client, *args) else raise UnknownMessage, "Unknown message '#{name}' received." end end ensure client_socket.close end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in start_synchronously # All hooks will be called, except before_fork(). def start_synchronously(socket_filename, password, server_socket, owner_socket) @owner_socket = owner_socket begin reset_signal_handlers initialize_server begin server_main_loop(password, server_socket) ensure finalize_server end rescue Interrupt # Do nothing ensure @owner_socket = nil /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in start # result in mysterious 'EBADFD' errors. So we force RubyGems to # clear all open file handles. Gem.clear_paths # Reseed pseudo-random number generator for security reasons. srand start_synchronously(@socket_filename, @password, server_socket, b) rescue Interrupt # Do nothing. has_exception = true rescue Exception => e has_exception = true print_exception(self.class.to_s, e) ensure /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/rack/application_spawner.rb in start # Overrided from AbstractServer#start. # # May raise these additional exceptions: # - AppInitError: The Rack application raised an exception # or called exit() during startup. # - ApplicationSpawner::Error: The ApplicationSpawner server exited unexpectedly. def start super begin channel = MessageChannel.new(@owner_socket) unmarshal_and_raise_errors(channel, @options["print_exceptions"]) rescue IOError, SystemCallError, SocketError => e stop if started? raise Error, "The application spawner server exited unexpectedly: #{e}" rescue /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/spawn_manager.rb in spawn_rack_application spawner = @spawners.lookup_or_add(key) do spawner_timeout = options["app_spawner_timeout"] spawner = Rack::ApplicationSpawner.new( @options.merge(options)) if spawner_timeout != -1 spawner.max_idle_time = spawner_timeout end spawner.start spawner end begin return spawner.spawn_application(options) rescue AbstractServer::ServerError @spawners.delete(key) raise /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server_collection.rb in lookup_or_add raise ArgumentError, "cleanup() has already been called." if @done must_be_in_synchronize_block server = @collection[key] if server register_activity(server) return server else server = yield if !server.respond_to?(:start) raise TypeError, "The block didn't return a valid AbstractServer object." end if eligable_for_cleanup?(server) server.next_cleaning_time = Time.now + server.max_idle_time if @next_cleaning_time && server.next_cleaning_time < @next_cleaning_time @next_cleaning_time = server.next_cleaning_time /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/spawn_manager.rb in spawn_rack_application create_spawner = nil key = nil case spawn_method when nil, "", "smart", "smart-lv2" @spawners.synchronize do key = "app:#{app_group_name}" spawner = @spawners.lookup_or_add(key) do spawner_timeout = options["app_spawner_timeout"] spawner = Rack::ApplicationSpawner.new( @options.merge(options)) if spawner_timeout != -1 spawner.max_idle_time = spawner_timeout end spawner.start /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server_collection.rb in synchronize # Acquire the lock for this AbstractServerCollection object, and run # the code within the block. The entire block will be a single atomic # operation. def synchronize @lock.synchronize do @in_synchronize_block = true begin yield ensure if @next_cleaning_time.nil? @collection.each_value do |server| if @next_cleaning_time.nil? || (eligable_for_cleanup?(server) && server.next_cleaning_time < @next_cleaning_time ) /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server_collection.rb in synchronize end end # Acquire the lock for this AbstractServerCollection object, and run # the code within the block. The entire block will be a single atomic # operation. def synchronize @lock.synchronize do @in_synchronize_block = true begin yield ensure if @next_cleaning_time.nil? @collection.each_value do |server| if @next_cleaning_time.nil? || /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/spawn_manager.rb in spawn_rack_application spawn_method = options["spawn_method"] spawner = nil create_spawner = nil key = nil case spawn_method when nil, "", "smart", "smart-lv2" @spawners.synchronize do key = "app:#{app_group_name}" spawner = @spawners.lookup_or_add(key) do spawner_timeout = options["app_spawner_timeout"] spawner = Rack::ApplicationSpawner.new( @options.merge(options)) if spawner_timeout != -1 spawner.max_idle_time = spawner_timeout /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/spawn_manager.rb in spawn_application require 'phusion_passenger/classic_rails/application_spawner' end return spawn_rails_application(options) when "rack" if !defined?(Rack::ApplicationSpawner) require 'phusion_passenger/rack/application_spawner' end return spawn_rack_application(options) when "wsgi" if !defined?(WSGI::ApplicationSpawner) require 'phusion_passenger/wsgi/application_spawner' end return WSGI::ApplicationSpawner.spawn_application(options) else raise ArgumentError, "Unknown 'app_type' value '#{options["app_type"]}'." /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/spawn_manager.rb in handle_spawn_application def handle_spawn_application(client, *options) options = sanitize_spawn_options(Hash[*options]) app_process = nil app_root = options["app_root"] app_type = options["app_type"] begin app_process = spawn_application(options) rescue AbstractServer::ServerError => e send_error_page(client, 'general_error', :error => e) rescue VersionNotFound => e send_error_page(client, 'version_not_found', :error => e, :app_root => app_root) rescue AppInitError => e if database_error?(e) send_error_page(client, 'database_error', :error => e, /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in __send__ if client_password != password next end name, *args = client.read if name if @message_handlers.has_key?(name) __send__(@message_handlers[name], client, *args) else raise UnknownMessage, "Unknown message '#{name}' received." end end ensure client_socket.close end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in server_main_loop if client_password != password next end name, *args = client.read if name if @message_handlers.has_key?(name) __send__(@message_handlers[name], client, *args) else raise UnknownMessage, "Unknown message '#{name}' received." end end ensure client_socket.close end /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/lib/phusion_passenger/abstract_server.rb in start_synchronously # All hooks will be called, except before_fork(). def start_synchronously(socket_filename, password, server_socket, owner_socket) @owner_socket = owner_socket begin reset_signal_handlers initialize_server begin server_main_loop(password, server_socket) ensure finalize_server end rescue Interrupt # Do nothing ensure @owner_socket = nil /usr/lib/ruby/gems/1.8/gems/passenger-3.0.7/helper-scripts/passenger-spawn-server in nil "logging_agent_password_base64" => logging_agent_password_base64, "node_name" => node_name } end require 'phusion_passenger/spawn_manager' spawn_manager = PhusionPassenger::SpawnManager.new(options) spawn_manager.start_synchronously(socket_filename, socket_password, server_socket, owner_socket) spawn_manager.cleanup rescue => e require 'phusion_passenger/utils' include PhusionPassenger::Utils print_exception("spawn manager", e) exit 10 end

GET No GET data.

POST No POST data.

COOKIES No cookie data.

Rack ENV Variable Value CONTENT_LENGTH 0 DOCUMENT_ROOT /var/cap/attr/current/public HTTP_ACCEPT */* HTTP_ACCEPT_ENCODING gzip, deflate HTTP_HOST media.talkingpointsmemo.com HTTP_USER_AGENT newspaper/0.1.2 PASSENGER_APP_SPAWNER_IDLE_TIME -1 PASSENGER_APP_TYPE rack PASSENGER_CONNECT_PASSWORD 3DGcUHBgqSZISrsCVt1pRf7UN2C5av08cr74ZkHgaBF PASSENGER_DEBUGGER false PASSENGER_ENVIRONMENT production PASSENGER_FRAMEWORK_SPAWNER_IDLE_TIME -1 PASSENGER_FRIENDLY_ERROR_PAGES true PASSENGER_GROUP PASSENGER_MIN_INSTANCES 10 PASSENGER_SHOW_VERSION_IN_HEADER true PASSENGER_SPAWN_METHOD smart-lv2 PASSENGER_USER PASSENGER_USE_GLOBAL_QUEUE true PATH_INFO /slideshow/astronomy-photographer-competition-2013 QUERY_STRING REMOTE_ADDR 50.159.87.221 REMOTE_PORT 50091 REQUEST_METHOD GET REQUEST_URI /slideshow/astronomy-photographer-competition-2013 SCGI 1 SCRIPT_NAME SERVER_ADDR 50.56.127.135 SERVER_NAME attr SERVER_PORT 80 SERVER_PROTOCOL HTTP/1.1 SERVER_SOFTWARE nginx/1.0.0 UNION_STATION_SUPPORT false _ _ rack.errors #<Object:0x7f4e47e91820> rack.input #<PhusionPassenger::Utils::RewindableInput:0x7f4e451da5e8 @rewindable_io=nil, @io=#<PhusionPassenger::Utils::UnseekableSocket:0x7f4e47c09558 @socket=#<UNIXSocket:0x7f4e451db6f0>>, @unlinked=false> rack.multiprocess true rack.multithread false rack.request.query_hash {} rack.request.query_string rack.run_once false rack.url_scheme http rack.version [1, 0] sinatra.error #<OpenURI::HTTPError: 404 Not Found>